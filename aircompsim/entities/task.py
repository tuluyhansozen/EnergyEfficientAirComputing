"""Task and Application definitions.

This module provides Task, Application, and ApplicationType classes
for modeling computational workloads in the simulation.
"""

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import TYPE_CHECKING, Optional, List, Dict, ClassVar

import numpy as np

if TYPE_CHECKING:
    from aircompsim.entities.server import Server
    from aircompsim.entities.user import User
    from aircompsim.entities.location import Location

logger = logging.getLogger(__name__)


class OffloadEntity(Enum):
    """Task offloading source and destination types.
    
    Attributes:
        USER_TO_EDGE: User offloads to edge server.
        USER_TO_UAV: User offloads to UAV.
        USER_TO_CLOUD: User offloads to cloud.
        EDGE_TO_UAV: Edge server offloads to UAV.
        EDGE_TO_CLOUD: Edge server offloads to cloud.
        UAV_TO_CLOUD: UAV offloads to cloud.
        UAV_TO_EDGE: UAV offloads to edge server.
    """
    
    USER_TO_EDGE = auto()
    USER_TO_UAV = auto()
    USER_TO_CLOUD = auto()
    EDGE_TO_UAV = auto()
    EDGE_TO_CLOUD = auto()
    UAV_TO_CLOUD = auto()
    UAV_TO_EDGE = auto()


@dataclass
class ApplicationType:
    """Defines an application type with QoS requirements.
    
    Application types define the characteristics of applications
    that generate tasks, including CPU requirements and latency constraints.
    
    Attributes:
        name: Human-readable application name.
        cpu_cycle: Required CPU cycles per task (in cycles).
        worst_delay: Maximum tolerable delay in seconds.
        best_delay: Target delay for optimal QoS in seconds.
        interarrival_time: Mean time between tasks in seconds.
        
    Example:
        >>> app_type = ApplicationType(
        ...     name="AR",
        ...     cpu_cycle=600,
        ...     worst_delay=0.1,
        ...     best_delay=0.05,
        ...     interarrival_time=0.5
        ... )
    """
    
    name: str
    cpu_cycle: float
    worst_delay: float
    best_delay: float
    interarrival_time: float
    
    # Class-level registry
    _registry: ClassVar[Dict[str, ApplicationType]] = {}
    
    def __post_init__(self) -> None:
        """Register application type."""
        ApplicationType._registry[self.name] = self
    
    @classmethod
    def get(cls, name: str) -> Optional[ApplicationType]:
        """Get application type by name."""
        return cls._registry.get(name)
    
    @classmethod
    def clear_registry(cls) -> None:
        """Clear all registered application types."""
        cls._registry.clear()
    
    @classmethod
    def get_all(cls) -> Dict[str, ApplicationType]:
        """Get all registered application types."""
        return cls._registry.copy()


# Pre-defined application types
ENTERTAINMENT_APP = ApplicationType(
    name="Entertainment",
    cpu_cycle=100,
    worst_delay=0.3,
    best_delay=0.1,
    interarrival_time=10
)

MULTIMEDIA_APP = ApplicationType(
    name="Multimedia",
    cpu_cycle=100,
    worst_delay=3.0,
    best_delay=0.1,
    interarrival_time=10
)

RENDERING_APP = ApplicationType(
    name="Rendering",
    cpu_cycle=200,
    worst_delay=1.0,
    best_delay=0.5,
    interarrival_time=20
)

IMAGE_CLASSIFICATION_APP = ApplicationType(
    name="ImageClassification",
    cpu_cycle=600,
    worst_delay=1.0,
    best_delay=0.5,
    interarrival_time=20
)


@dataclass
class Task:
    """Represents a computational task to be offloaded.
    
    Tasks are generated by applications and processed by servers.
    Each task tracks its lifecycle from creation to completion.
    
    Attributes:
        app: Parent application.
        user: User that generated the task.
        creation_time: Simulation time when task was created.
        task_id: Unique task identifier.
        end_time: Completion time (-1 if not complete).
        processing_time: Time spent processing.
        waiting_time_in_queue: Time spent waiting in server queue.
        qos: Quality of Service score (0-100).
        is_success: Whether task completed within deadline.
        offload_entity: Type of offload operation.
        processed_server: Server that processed the task.
        
    Example:
        >>> task = Task(app=my_app, user=my_user, creation_time=10.5)
        >>> print(f"Task {task.task_id} created at {task.creation_time}")
    """
    
    app: Application
    user: User
    creation_time: float
    task_id: int = field(default=0)
    end_time: float = -1.0
    processing_time: float = 0.0
    waiting_time_in_queue: float = 0.0
    qos: int = -1
    is_success: bool = False
    offload_entity: Optional[OffloadEntity] = None
    offload_location: Optional[Location] = None
    process_location: Optional[Location] = None
    processed_server: Optional[Server] = None
    return_location: Optional[Location] = None
    
    # Class-level tracking
    _id_counter: ClassVar[int] = 0
    _all_tasks: ClassVar[List[Task]] = []
    
    def __post_init__(self) -> None:
        """Initialize task with unique ID and set offload location."""
        Task._id_counter += 1
        object.__setattr__(self, 'task_id', Task._id_counter)
        Task._all_tasks.append(self)
        
        # Set offload location from user
        if self.user is not None:
            self.offload_location = self.user.current_location
        
        # Default offload entity
        if self.offload_entity is None:
            self.offload_entity = OffloadEntity.USER_TO_EDGE
        
        logger.debug(
            f"Task {self.task_id} created for app {self.app.app_id} "
            f"at time {self.creation_time:.2f}"
        )
    
    @property
    def latency(self) -> float:
        """Get task latency (end time - creation time).
        
        Returns:
            Latency in seconds, or -1 if not completed.
        """
        if self.end_time < 0:
            return -1.0
        return self.end_time - self.creation_time
    
    def compute_qos(self) -> int:
        """Compute Quality of Service score based on latency.
        
        Returns:
            QoS score: 0 (failed), 50 (acceptable), 100 (excellent).
        """
        latency = self.latency
        if latency < 0:
            return -1
        
        if latency > self.app.worst_delay:
            self.qos = 0
        elif latency < self.app.best_delay:
            self.qos = 100
        else:
            self.qos = 50
        
        return self.qos
    
    def check_success(self) -> bool:
        """Check if task completed within deadline.
        
        Returns:
            True if latency is within worst_delay.
        """
        latency = self.latency
        if latency < 0:
            self.is_success = False
        else:
            self.is_success = latency <= self.app.worst_delay
        return self.is_success
    
    def complete(self, end_time: float, server: Server) -> None:
        """Mark task as complete.
        
        Args:
            end_time: Simulation time of completion.
            server: Server that processed the task.
        """
        self.end_time = end_time
        self.processed_server = server
        self.compute_qos()
        self.check_success()
        
        logger.debug(
            f"Task {self.task_id} completed: latency={self.latency:.3f}s, "
            f"qos={self.qos}, success={self.is_success}"
        )
    
    @classmethod
    def reset_all(cls) -> None:
        """Reset task counter and clear all tasks."""
        cls._id_counter = 0
        cls._all_tasks.clear()
        logger.debug("Task registry reset")
    
    @classmethod
    def get_all_tasks(cls) -> List[Task]:
        """Get all created tasks."""
        return cls._all_tasks.copy()
    
    @classmethod
    def get_task_count(cls) -> int:
        """Get total number of tasks created."""
        return cls._id_counter


@dataclass
class Application:
    """Represents an application instance that generates tasks.
    
    Applications belong to users and generate tasks based on
    their application type's characteristics.
    
    Attributes:
        app_type: Type definition for this application.
        start_time: Simulation time when application started.
        app_id: Unique application identifier.
        user_id: ID of owning user.
        tasks: List of generated tasks.
        
    Example:
        >>> app = Application(app_type=ENTERTAINMENT_APP, start_time=0)
        >>> task = app.generate_task(user, current_time=10.0)
    """
    
    app_type: ApplicationType
    start_time: float
    app_id: int = field(default=0)
    user_id: Optional[int] = None
    tasks: List = field(default_factory=list)
    _inner_time: float = field(default=0.0, repr=False)
    _qos: float = field(default=0.0, repr=False)
    _waiting_time: float = field(default=0.0, repr=False)
    
    # Class-level tracking
    _id_counter: ClassVar[int] = 0
    _all_applications: ClassVar[List[Application]] = []
    
    def __post_init__(self) -> None:
        """Initialize application with unique ID."""
        Application._id_counter += 1
        object.__setattr__(self, 'app_id', Application._id_counter)
        self._inner_time = self.start_time
        Application._all_applications.append(self)
        
        logger.debug(f"Application {self.app_id} ({self.name}) created")
    
    def __eq__(self, other: object) -> bool:
        """Check equality by ID."""
        if not isinstance(other, Application):
            return NotImplemented
        return self.app_id == other.app_id
    
    def __hash__(self) -> int:
        """Hash by ID."""
        return hash(("Application", self.app_id))
    
    @property
    def name(self) -> str:
        """Get application type name."""
        return self.app_type.name
    
    @property
    def cpu_cycle(self) -> float:
        """Get required CPU cycles."""
        return self.app_type.cpu_cycle
    
    @property
    def worst_delay(self) -> float:
        """Get maximum tolerable delay."""
        return self.app_type.worst_delay
    
    @property
    def best_delay(self) -> float:
        """Get target delay."""
        return self.app_type.best_delay
    
    @property
    def interarrival_time(self) -> float:
        """Get mean time between tasks."""
        return self.app_type.interarrival_time
    
    def is_task_valid(self, sim_time: float) -> bool:
        """Check if it's time to generate a new task.
        
        Args:
            sim_time: Current simulation time.
            
        Returns:
            True if a new task should be generated.
        """
        return self._inner_time < sim_time
    
    def generate_task(self, user: User) -> Task:
        """Generate a new task for this application.
        
        Uses exponential distribution for interarrival times.
        
        Args:
            user: User generating the task.
            
        Returns:
            New Task instance.
        """
        # Exponential interarrival time
        interarrival = -np.log(1 - np.random.uniform(0, 1)) * self.interarrival_time
        creation_time = self._inner_time + interarrival
        
        task = Task(
            app=self,
            user=user,
            creation_time=creation_time,
            offload_entity=OffloadEntity.USER_TO_EDGE
        )
        
        self.tasks.append(task)
        self._inner_time = creation_time
        
        logger.debug(
            f"Application {self.app_id} generated task {task.task_id} "
            f"at time {creation_time:.2f}"
        )
        
        return task
    
    def compute_mean_interarrival(self) -> float:
        """Compute mean interarrival time from actual tasks.
        
        Returns:
            Mean interarrival time in seconds.
        """
        if len(self.tasks) < 2:
            return self.interarrival_time
        
        total_interval = 0.0
        for i in range(1, len(self.tasks)):
            total_interval += self.tasks[i].creation_time - self.tasks[i-1].creation_time
        
        mean = total_interval / (len(self.tasks) - 1)
        logger.debug(f"Application {self.app_id} mean interarrival: {mean:.3f}s")
        return mean
    
    def compute_qos(self, warmup_period: float = 100.0) -> float:
        """Compute average QoS for this application.
        
        Args:
            warmup_period: Ignore tasks before this time.
            
        Returns:
            Average QoS score (0-100).
        """
        completed_tasks = [
            t for t in self.tasks 
            if t.creation_time > warmup_period and t.qos >= 0
        ]
        
        if not completed_tasks:
            return 0.0
        
        self._qos = sum(t.qos for t in completed_tasks) / len(completed_tasks)
        self._waiting_time = sum(t.latency for t in completed_tasks) / len(completed_tasks)
        
        logger.debug(
            f"Application {self.app_id} QoS: {self._qos:.1f}, "
            f"avg latency: {self._waiting_time:.3f}s"
        )
        
        return self._qos
    
    def get_statistics(self, warmup_period: float = 100.0) -> dict:
        """Get application statistics.
        
        Args:
            warmup_period: Ignore tasks before this time.
            
        Returns:
            Dictionary with statistics.
        """
        valid_tasks = [t for t in self.tasks if t.creation_time > warmup_period]
        successful = [t for t in valid_tasks if t.is_success]
        
        return {
            "app_id": self.app_id,
            "app_type": self.name,
            "total_tasks": len(valid_tasks),
            "successful_tasks": len(successful),
            "success_rate": len(successful) / len(valid_tasks) if valid_tasks else 0,
            "avg_qos": self.compute_qos(warmup_period),
            "avg_latency": self._waiting_time
        }
    
    @classmethod
    def reset_all(cls) -> None:
        """Reset application counter and clear all applications."""
        cls._id_counter = 0
        cls._all_applications.clear()
        Task.reset_all()
        logger.debug("Application registry reset")
    
    @classmethod
    def get_all_applications(cls) -> List[Application]:
        """Get all created applications."""
        return cls._all_applications.copy()
    
    @classmethod
    def remove_application(cls, app_id: int) -> bool:
        """Remove an application by ID.
        
        Args:
            app_id: Application ID to remove.
            
        Returns:
            True if removed, False if not found.
        """
        for i, app in enumerate(cls._all_applications):
            if app.app_id == app_id:
                cls._all_applications.pop(i)
                logger.info(f"Application {app_id} removed")
                return True
        return False
